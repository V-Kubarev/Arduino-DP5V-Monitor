# Принципы работы прошивки

---
  
 ## Принцип подсчета импульсов: Аппаратные прерывания

  Надежный подсчет каждого импульса от счетчика Гейгера — это самая фундаментальная задача дозиметра. Для ее решения в проекте используется механизм
  аппаратных прерываний, который является наиболее точным и эффективным способом регистрации быстрых, асинхронных событий.

  Проблема: Непредсказуемость и краткость импульсов

  Импульсы от счетчика Гейгера обладают двумя особенностями, которые делают их подсчет сложной задачей:

   * Случайность: Они могут прийти в любой момент времени.
   * Краткость: Длительность одного импульса очень мала (порядка микросекунд).

  Если бы мы пытались "ловить" импульсы простым чтением состояния пина в основном цикле `loop()` (метод, называемый "опросом" или "polling"), мы бы почти
  наверняка пропустили большинство из них. В тот момент, когда приходит короткий импульс, микроконтроллер может быть занят другими делами: обновлением
  экрана, математическими расчетами или обработкой кнопки.

  Решение: Использование аппаратных прерываний

  Аппаратное прерывание можно представить как "экстренный телефонный звонок" для микроконтроллера.

  Когда на специальном пине прерывания происходит заданное событие (например, изменение напряжения), микроконтроллер немедленно останавливает
  выполнение текущего кода в `loop()`, выполняет специальную, короткую функцию-обработчик (ISR - Interrupt Service Routine), а затем возвращается ровно в
  то место, где его прервали.

  Это гарантирует, что ни один, даже самый короткий импульс, не будет пропущен, чем бы в этот момент ни был занят основной цикл программы.

  Принцип реализации в коде

  1. Настройка в `setup()`

  В функции `setup()` мы "сообщаем" микроконтроллеру, какой пин слушать и какую функцию вызывать.
```
   // Настраиваем пин как вход с подтягивающим резистором к питанию.
   // В обычном состоянии на нем будет HIGH (логическая 1).
   pinMode(GEIGER_PIN, INPUT_PULLUP);
   
   // "Прикрепляем" прерывание к этому пину
   attachInterrupt(digitalPinToInterrupt(GEIGER_PIN), geigerISR, RISING);
```
  Разберем команду attachInterrupt:
   * `digitalPinToInterrupt(GEIGER_PIN)`: Преобразует номер пина (D2) во внутренний номер прерывания (INT0).
   * geigerISR: Имя функции, которая будет вызвана при срабатывании прерывания.
   * RISING: Условие срабатывания. Прерывание произойдет в тот момент, когда напряжение на пине изменится с низкого (LOW) на высокое (HIGH). Это
     происходит, когда импульс от схемы согласования заканчивается, и пин возвращается в свое нормальное состояние благодаря подтягивающему резистору.

  2. Обработчик прерывания — `geigerISR()`

  Это та самая "экстренная" функция. Она должна быть максимально короткой и быстрой. В ней нельзя использовать `delay()` или долгие операции.
```
   void geigerISR() {
     // ... (проверка на программное мёртвое время) ...
   
     // 1. Увеличиваем общий счетчик импульсов
     pulseCount++;
   
     // 2. Устанавливаем флаг для звуковой индикации в основном цикле
     beepFlag = true;
   }
```
  Все, что она делает, — это увеличивает счетчик `pulseCount` и выставляет флаг `beepFlag`, чтобы основной цикл `loop()` знал, что нужно издать звук и
  моргнуть светодиодом.

  Переменные, которые используются и в прерывании, и в основном цикле (`pulseCount`, `beepFlag`), обязательно объявляются с ключевым словом volatile. Это
  сообщает компилятору, что значение переменной может измениться в любой момент, и запрещает ему применять некоторые виды оптимизации, которые могли бы
  нарушить логику.

  3. Безопасное чтение счетчика в `loop()`

  Переменная pulseCount имеет тип unsigned long и занимает 4 байта. Чтение 4 байт не является атомарной (мгновенной) операцией. Существует крошечный
  шанс, что прерывание произойдет прямо в середине чтения этой переменной, что приведет к получению неверного значения.

  Чтобы этого избежать, перед чтением pulseCount мы временно отключаем все прерывания, а сразу после чтения — включаем обратно.
```
   unsigned long currentCount;

   noInterrupts(); // Запрещаем прерывания
   currentCount = pulseCount; // Безопасно читаем значение
   interrupts(); // Сразу же разрешаем прерывания обратно
```
  Это гарантирует, что значение pulseCount будет прочитано корректно и без искажений.

---
  
  ## Алгоритм скользящего окна (Sliding Window Algorithm)

  Для получения стабильных и достоверных показаний мощности дозы в проекте используется алгоритм усреднения данных по методу скользящего окна. Ниже
  приведено детальное описание его работы.

  Проблема: Случайная природа радиации

  Радиоактивный распад является стохастическим (случайным) процессом. Даже при неизменном радиационном фоне количество частиц, регистрируемых
  детектором за единицу времени, постоянно колеблется. Измерение количества импульсов в секунду (CPS - Counts Per Second) на основе данных только за
  последнюю секунду привело бы к следующим проблемам:

   * Нестабильность показаний: Значения на дисплее постоянно "прыгали" бы (например, 0, 2, 1, 0, 3...), что делает невозможным адекватную оценку
     текущего уровня.
   * Низкая достоверность: Односекундное измерение не является статистически значимым, особенно при низких уровнях радиации.

  Решение: Усреднение по скользящему окну

  Чтобы решить эту проблему, применяется усреднение данных за более длительный, но постоянно обновляемый промежуток времени. Алгоритм скользящего окна
  реализует именно этот подход.

  Основная идея: В любой момент времени мы оперируем средним значением, вычисленным на основе данных за последние N секунд (в данном проекте N = 30).
  Каждую новую секунду самые свежие данные добавляются в набор для усреднения, а самые старые (которые были N+1 секунду назад) — отбрасываются. Таким
  образом, окно измерений как бы "скользит" по временной шкале, всегда оставаясь актуальным.

  Принцип реализации в коде

  Для эффективной реализации алгоритма используется кольцевой (или циклический) буфер.


  1. Кольцевой буфер

  В коде создается массив, который хранит количество импульсов, зарегистрированное за каждую из последних 30 секунд.
```
    #define WINDOW_SECONDS 30
    unsigned int cpsBuffer[WINDOW_SECONDS] = {0};
```

  Этот массив можно представить как 30 ячеек памяти, каждая для своей секунды.


  2. Ежесекундное обновление

  Раз в секунду основной цикл выполняет блок кода, отвечающий за обновление данных.


  3. Запись новых данных

  Сначала вычисляется количество импульсов, произошедших за последнюю секунду, а затем это значение записывается в текущую ячейку буфера. Указатель на
  текущую ячейку хранится в переменной bufferIndex.
```
   // Вычисляем импульсы за прошедшую секунду
   unsigned int pulsesThisSecond = currentCount - lastPulseSnapshot;
   // Записываем их в текущую ячейку
   cpsBuffer[bufferIndex] = pulsesThisSecond;
```

  4. Сдвиг окна

  После записи новых данных указатель bufferIndex сдвигается на следующую ячейку. Для "зацикливания" буфера используется оператор остатка от деления
  (%).
  ```
  bufferIndex = (bufferIndex + 1) % WINDOW_SECONDS;
  ```
  Когда bufferIndex достигает значения 29, на следующей итерации (29 + 1) % 30 дает в результате 0. Указатель возвращается в начало массива, и новыеданные начинают перезаписывать самые старые значения. Именно так и реализуется "скольжение" —    старые данные автоматически "забываются".


  5. Расчет среднего значения (CPS)

  Каждую секунду, после обновления буфера, программа заново вычисляет сумму всех значений в 30 ячейках.
```
   unsigned long windowPulses = 0;
   for (unsigned int i = 0; i < WINDOW_SECONDS; i++) {
     windowPulses += cpsBuffer[i];
   }
```
  Полученное значение `windowPulses` — это общее количество импульсов за последние 30 секунд. Для нахождения среднего значения в секунду (CPS), эта сумма
  делится на длительность окна.
```
    float cps = windowPulses / (float)WINDOW_SECONDS;
```
  Именно это усредненное значение CPS затем используется для всех дальнейших расчетов (мощности дозы, погрешности и т.д.).

  Преимущества данного подхода

   * Стабильность: Алгоритм эффективно сглаживает случайные флуктуации, предоставляя пользователю стабильное и легко читаемое значение.
   * Актуальность: В отличие от простого накопления, метод использует только свежие данные. Если радиационная обстановка изменится (например, вы
     поднесете прибор к источнику), показания плавно и предсказуемо обновятся до нового уровня в течение 30 секунд.
---

  ## Алгоритм расчета статистической погрешности

  Помимо самого значения мощности дозы, прибор также рассчитывает и отображает относительную статистическую погрешность измерения в процентах. Этот
  параметр показывает, насколько можно "доверять" текущим показаниям.

  Проблема: Неопределенность случайных событий

  Радиоактивный распад — это случайный (стохастический) процесс. Это означает, что невозможно предсказать, когда именно произойдет следующий распад.
  Из-за этой случайности любое измерение, основанное на подсчете числа событий, имеет встроенную неопределенность.

  Например, показание 0.24 uSv/h само по себе малоинформативно. Гораздо полезнее знать, это 0.24 ± 0.50 uSv/h (очень недостоверное измерение) или 0.24
  ± 0.01 uSv/h (очень достоверное измерение). Статистическая погрешность как раз и дает эту оценку достоверности.

  Теоретическая основа: Статистика Пуассона

  Процессы случайного распада хорошо описываются распределением Пуассона. Один из ключевых выводов этой теории гласит:

  > Если за определенный промежуток времени было зарегистрировано N случайных событий, то стандартное отклонение (которое и является мерой абсолютной
  статистической погрешности) этого измерения приблизительно равно квадратному корню из N (√N).

  Простой пример:
   * Если мы насчитали 100 импульсов, абсолютная погрешность составит √100 = 10 импульсов. Это значит, что "истинное" среднее значение, скорее всего,
     лежит в диапазоне 100 ± 10 (от 90 до 110).
   * Если мы насчитали 10000 импульсов, абсолютная погрешность составит √10000 = 100 импульсов. Диапазон: 10000 ± 100.

  Обратите внимание: чем больше событий мы регистрируем, тем больше абсолютная погрешность, но тем меньше она по отношению к самому значению (10 по
  отношению к 100 — это 10%, а 100 по отношению к 10000 — это всего 1%). Именно эту относительную погрешность в процентах и рассчитывает прибор.

  Реализация в коде

  1. Получение общего числа событий (N)

  В качестве N используется общее количество импульсов, накопленное в скользящем окне за 30 секунд. Это переменная `windowPulses`.

  2. Формула относительной погрешности

  Относительная погрешность вычисляется как отношение стандартного отклонения к измеренному значению:
   * Относительная погрешность = (√N) / N

  Эту дробь можно математически упростить до 1 / √N.

  Чтобы выразить это значение в процентах, мы просто умножаем результат на 100.
   * Относительная погрешность (%) = (1 / √N) * 100  или  100 / √N

  3. Код расчета

  Именно эта формула и реализована в  коде:
```
   float errorPercent = 0.0;
   // Проверяем, что импульсы вообще были, чтобы избежать деления на ноль
   if (windowPulses > 0) {
     //           100.0      /      √N
     errorPercent = 100.0 / sqrt(windowPulses);
   }
```

  Практическое значение для пользователя

  Этот процент на экране дает интуитивно понятную оценку надежности текущих показаний:

   * Высокая погрешность (например, > 20-30%): Возникает при низком радиационном фоне, когда за 30 секунд регистрируется мало импульсов. Это говорит
     пользователю, что текущее значение мощности дозы "шумное" и не очень стабильное.
   * Низкая погрешность (например, < 5%): Возникает при высоком радиационном фоне, когда за 30 секунд регистрируются сотни или тысячи импульсов. Это
     говорит о том, что измерение статистически значимо, а показания мощности дозы — надежны и стабильны.
---

  ## Алгоритм накопления дозы (Dose Accumulation)

  Одной из ключевых функций прибора является подсчет суммарной дозы, полученной за время измерения. Этот процесс называется накоплением дозы и работает
  параллельно с измерением текущей мощности дозы.

  Назначение и отличия от мощности дозы

  Важно понимать разницу между мощностью дозы и накопленной дозой. Для этого удобно использовать аналогию с автомобилем:

   * Мощность дозы (µSv/h): Это как спидометр в автомобиле. Он показывает, насколько "быстро" вы получаете дозу в данный момент. Значение может
     меняться каждую секунду в зависимости от радиационной обстановки.

   * Накопленная доза (µSv): Это как одометр (счетчик общего пробега). Он показывает, какую суммарную дозу вы "проехали", то есть получили с самого
     начала измерения (или с момента последнего сброса). Это значение только растет со временем.

  Накопленная доза является более важным параметром для оценки общего воздействия радиации на организм за определенный период.

  Принцип реализации в коде

  Алгоритм основан на принципе дискретного интегрирования. Так как мощность дозы — это скорость ее получения, то сама доза — это интеграл от мощности
  по времени. В цифровом виде мы аппроксимируем этот процесс путем суммирования маленьких "порций" дозы, полученных за короткие промежутки времени (в
  нашем случае — за одну секунду).

  1. Исходные данные

  Каждую секунду, после усреднения по скользящему окну, мы получаем значение мощности дозы в переменной doseRate_uSv. Единицы измерения этой переменной
  — микрозиверт в час (µSv/h).

  2. Пересчет в дозу за секунду

  Чтобы узнать, какая доза была получена за одну секунду, необходимо перевести часовую ставку в секундную. В одном часе 3600 секунд, поэтому формула
  проста:

  > Доза за секунду = (Мощность дозы в час) / 3600

  3. Суммирование (Накопление)

  Эта небольшая, полученная за секунду порция дозы, добавляется к общему счетчику накопленной дозы. Этот процесс повторяется каждую секунду.
```
   // doseRate_uSv имеет единицы [мкЗв/час]
   // Чтобы получить дозу за одну секунду, делим на 3600
   accumulatedDose_uSv += doseRate_uSv / 3600.0;
```
  Одновременно с этим увеличивается на единицу счетчик общего времени измерения:
```
   1 accumulationTime_s++;
```

  4. Непрерывность процесса

  Ключевой особенностью является то, что этот расчет происходит каждую секунду в фоновом режиме, независимо от того, какой экран выбран пользователем.
  Благодаря этому, даже если пользователь находится на основном экране, накопление дозы не прекращается, и при переключении на экран накопленной дозы
  он увидит актуальное суммарное значение.

  Сброс измерений

  При длительном нажатии на кнопку вызывается функция `resetMeasurements()`. Она обнуляет как счетчик накопленной дозы, так и счетчик времени, что
  позволяет начать новый сеанс измерения с нуля.
```
   void resetMeasurements() {
     // ... (сброс других переменных)
     accumulatedDose_uSv = 0.0;
     accumulationTime_s = 0;
   }
```
  ## Принцип переключения режимов и управления

  Для взаимодействия с дозиметром используется одна кнопка, которая способна выполнять две разные функции в зависимости от длительности нажатия.
  Управление режимами отображения и сбросом измерений реализовано с помощью простого конечного автомата, отслеживающего состояние кнопки.

  Задача: Многофункциональная кнопка

  Цель состояла в том, чтобы с помощью одной физической кнопки реализовать два разных действия:
   * Короткое нажатие: Переключение между экранами (режимами отображения).
   * Долгое нажатие: Полный сброс всех накопленных данных.

  Реализация в коде

  Для решения этой задачи используется отслеживание состояния кнопки и замеры времени, в течение которого она была нажата.

  1. Переменные состояния

  Для управления режимами и состоянием кнопки используются следующие глобальные переменные:
```
    // Перечисление для хранения возможных режимов экрана
    enum DisplayMode {
      DISPLAY_MAIN,
      DISPLAY_ACCUM
    };
    // Переменная, хранящая текущий активный режим
    DisplayMode displayMode = DISPLAY_MAIN;
    
    // Переменные для обработки нажатий
    bool lastButtonState = HIGH;      // Предыдущее состояние кнопки
    unsigned long buttonPressTime = 0;  // Время, когда кнопка была нажата
    unsigned long lastButtonEvent = 0;  // Время последнего события для антидребезга
```
  2. Подавление дребезга (Debouncing)

  При физическом нажатии на кнопку ее контакты могут несколько раз замкнуться и разомкнуться в течение нескольких миллисекунд, создавая "дребезг".
  Чтобы одно нажатие не было воспринято как несколько, реализована программная защита.
```
   #define DEBOUNCE_MS 200 // Игнорировать новые нажатия в течение 200 мс
   
   // ... в основном цикле loop()
   if (buttonState == LOW && lastButtonState == HIGH &&
       nowMillis - lastButtonEvent > DEBOUNCE_MS) {
   
     buttonPressTime = nowMillis; // Засекаем время начала нажатия
     lastButtonEvent = nowMillis; // Обновляем время последнего события
   }
```
  Этот код срабатывает только в самый первый момент нажатия (когда состояние меняется с HIGH на LOW) и только если с момента последнего события прошло
  более 200 мс.

  3. Определение длительности нажатия

  Логика определения действия срабатывает в момент, когда кнопка отпускается.
```
   // Срабатывает, когда состояние меняется с LOW на HIGH
   if (buttonState == HIGH && lastButtonState == LOW) {
      // Вычисляем, как долго кнопка была зажата
      unsigned long pressDuration = nowMillis - buttonPressTime;
   
      // ... (далее следует логика выбора действия)
   }
```
  4. Логика короткого и долгого нажатия

  Внутри блока, который сработал при отпускании кнопки, мы анализируем вычисленную длительность pressDuration:
```
    #define LONG_PRESS_MS 1500 // Порог для долгого нажатия = 1.5 секунды
    
    // Если кнопка была зажата дольше порога
    if (pressDuration >= LONG_PRESS_MS) {
      // Выполняем сброс всех измерений
      resetMeasurements();
    }
    // Если кнопка была зажата меньше порога
    else {
      // Выполняем переключение экрана
      displayMode = (displayMode == DISPLAY_MAIN) ? DISPLAY_ACCUM : DISPLAY_MAIN;
    }
```
  5. Переключение режимов

  Для смены режима используется тернарный оператор, который работает как компактная форма if-else:
   `displayMode = (displayMode == DISPLAY_MAIN) ? DISPLAY_ACCUM : DISPLAY_MAIN;`
  Эта строка читается так: "Если текущий режим (`displayMode`) равен `DISPLAY_MAIN`, то присвоить ему значение `DISPLAY_ACCUM`. В противном случае —
  присвоить `DISPLAY_MAIN`." Это эффективно переключает режим на противоположный.

  Управление выводом на дисплей

  В конце основного цикла `loop()` находится блок, который в зависимости от текущего значения переменной `displayMode` решает, какую именно информацию
  выводить на экран. Он работает как "маршрутизатор" отрисовки.
```
   if (displayMode == DISPLAY_MAIN) {
     // Код для отрисовки основного экрана
     // (CPS, B8, мощность дозы, погрешность)
   } else { // Если displayMode == DISPLAY_ACCUM
     // Код для отрисовки экрана накопленной дозы
     // (Время накопления, накопленная доза)
   }
```
---

  №№ Принцип вывода данных на экран

  Для отображения информации в проекте используется стандартный символьный дисплей LCD 16x2 с I2C-интерфейсом. Логика вывода данных организована таким
  образом, чтобы на небольшом экране помещалась вся необходимая информация, а интерфейс оставался чистым и читаемым.

  Задача: Информативный и чистый интерфейс

  Основная задача — эффективно использовать ограниченное пространство дисплея (2 строки по 16 символов) для отображения разных наборов данных в
  зависимости от выбранного пользователем режима, избегая при этом визуальных артефактов.

  Используемая библиотека

  Взаимодействие с дисплеем осуществляется через популярную библиотеку `LiquidCrystal_I2C`, которая значительно упрощает отправку команд и текста на
  дисплей по I2C-шине.
```
   #include <LiquidCrystal_I2C.h>
   LiquidCrystal_I2C lcd(0x27, 16, 2);
```
  Реализация в коде

  1. Маршрутизация отображения

  В основном цикле `loop()`, внутри ежесекундного блока обработки, находится if-else конструкция, которая работает как "маршрутизатор". Она проверяет
  текущее значение переменной `displayMode` и, в зависимости от него, вызывает соответствующий блок кода для отрисовки того или иного экрана.
```
   if (displayMode == DISPLAY_MAIN) {
     // Код для отрисовки основного экрана...
   } else { // Если displayMode == DISPLAY_ACCUM
     // Код для отрисовки экрана накопленной дозы...
   }
```
  2. Работа с курсором и очистка строк

  Перед выводом каждого блока информации позиция "каретки" на дисплее устанавливается вручную с помощью команды `lcd.setCursor(колонка, строка)`.
  Нумерация начинается с (0, 0) для верхнего левого угла.

  Решение проблемы "символов-призраков":
  При выводе на ЖК-дисплей значений переменной длины (например, числа 100, а затем 99) могут оставаться "хвосты" от предыдущих, более длинных значений.
   * Было: CPS:100
   * Стало: CPS:990 (ноль остался от числа 100)

  Чтобы этого избежать, в коде применяется простая, но эффективная техника: после вывода полезной информации строка дополняется пробелами до конца. Это
  гарантирует, что любая предыдущая запись на этой строке будет полностью затерта.
```
   // Пример очистки "хвоста" строки
   lcd.print(errorPercent, 1);
   lcd.print("%   "); // <-- Эти пробелы затирают старые символы
```
  3. Описание экранов

  ##### Экран 1: Основные измерения (DISPLAY_MAIN)

  Вид экрана:
   1 CPS:0.7 B8:42
   2 0.24uSv 12.1%
   * Верхняя строка: Устанавливается курсор в (0, 0). Выводится статический текст CPS:, затем значение cps с одним знаком после запятой, затем текст
     B8: и целочисленное значение b8Value.
   * Нижняя строка: Устанавливается курсор в (0, 1). Выводится мощность дозы doseRate_uSv с двумя знаками после запятой, единица измерения uSv, и
     относительная погрешность errorPercent с одним знаком после запятой и знаком %.

  ##### Экран 2: Накопленная доза (DISPLAY_ACCUM)

  Вид экрана:
   1 00:15:32
   2 0.0123 uSv
   * Верхняя строка: Отображает общее время накопления.
       * Сначала общее количество секунд accumulationTime_s раскладывается на часы, минуты и секунды с помощью целочисленного деления и оператора
         остатка от деления (%).
       * Затем каждая компонента выводится на экран с помощью логики, добавляющей ведущий ноль, если число меньше 10 (например, 01:05:09 вместо 1:5:9).
```
           if (hours < 10) lcd.print("0");
           lcd.print(hours);
```
   * Нижняя строка: Выводит суммарную накопленную дозу `accumulatedDose_uSv` с высокой точностью (4 знака после запятой) и единицу измерения uSv.

---
В перспективе:

* Принцип калибровки
* Принчип персчета CPS>mSv
