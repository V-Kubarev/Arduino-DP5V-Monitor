  Алгоритм скользящего окна (Sliding Window Algorithm)

  Для получения стабильных и достоверных показаний мощности дозы в проекте используется алгоритм усреднения данных по методу скользящего окна. Ниже
  приведено детальное описание его работы.

  Проблема: Случайная природа радиации

  Радиоактивный распад является стохастическим (случайным) процессом. Даже при неизменном радиационном фоне количество частиц, регистрируемых
  детектором за единицу времени, постоянно колеблется. Измерение количества импульсов в секунду (CPS - Counts Per Second) на основе данных только за
  последнюю секунду привело бы к следующим проблемам:

   * Нестабильность показаний: Значения на дисплее постоянно "прыгали" бы (например, 0, 2, 1, 0, 3...), что делает невозможным адекватную оценку
     текущего уровня.
   * Низкая достоверность: Односекундное измерение не является статистически значимым, особенно при низких уровнях радиации.

  Решение: Усреднение по скользящему окну

  Чтобы решить эту проблему, применяется усреднение данных за более длительный, но постоянно обновляемый промежуток времени. Алгоритм скользящего окна
  реализует именно этот подход.

  Основная идея: В любой момент времени мы оперируем средним значением, вычисленным на основе данных за последние N секунд (в данном проекте N = 30).
  Каждую новую секунду самые свежие данные добавляются в набор для усреднения, а самые старые (которые были N+1 секунду назад) — отбрасываются. Таким
  образом, окно измерений как бы "скользит" по временной шкале, всегда оставаясь актуальным.

  Принцип реализации в коде

  Для эффективной реализации алгоритма используется кольцевой (или циклический) буфер.


  1. Кольцевой буфер

  В коде создается массив, который хранит количество импульсов, зарегистрированное за каждую из последних 30 секунд.
```
    #define WINDOW_SECONDS 30
    unsigned int cpsBuffer[WINDOW_SECONDS] = {0};
```

  Этот массив можно представить как 30 ячеек памяти, каждая для своей секунды.


  2. Ежесекундное обновление

  Раз в секунду основной цикл выполняет блок кода, отвечающий за обновление данных.


  3. Запись новых данных

  Сначала вычисляется количество импульсов, произошедших за последнюю секунду, а затем это значение записывается в текущую ячейку буфера. Указатель на
  текущую ячейку хранится в переменной bufferIndex.
```
   // Вычисляем импульсы за прошедшую секунду
   unsigned int pulsesThisSecond = currentCount - lastPulseSnapshot;
   // Записываем их в текущую ячейку
   cpsBuffer[bufferIndex] = pulsesThisSecond;
```

  4. Сдвиг окна

  После записи новых данных указатель bufferIndex сдвигается на следующую ячейку. Для "зацикливания" буфера используется оператор остатка от деления
  (%).
  ```
  bufferIndex = (bufferIndex + 1) % WINDOW_SECONDS;
  ```
  Когда bufferIndex достигает значения 29, на следующей итерации (29 + 1) % 30 дает в результате 0. Указатель возвращается в начало массива, и новыеданные начинают перезаписывать самые старые значения. Именно так и реализуется "скольжение" —    старые данные автоматически "забываются".


  5. Расчет среднего значения (CPS)

  Каждую секунду, после обновления буфера, программа заново вычисляет сумму всех значений в 30 ячейках.
```
   unsigned long windowPulses = 0;
   for (unsigned int i = 0; i < WINDOW_SECONDS; i++) {
     windowPulses += cpsBuffer[i];
   }
```
  Полученное значение windowPulses — это общее количество импульсов за последние 30 секунд. Для нахождения среднего значения в секунду (CPS), эта сумма
  делится на длительность окна.
```
    float cps = windowPulses / (float)WINDOW_SECONDS;
```
  Именно это усредненное значение CPS затем используется для всех дальнейших расчетов (мощности дозы, погрешности и т.д.).

  Преимущества данного подхода

   * Стабильность: Алгоритм эффективно сглаживает случайные флуктуации, предоставляя пользователю стабильное и легко читаемое значение.
   * Актуальность: В отличие от простого накопления, метод использует только свежие данные. Если радиационная обстановка изменится (например, вы
     поднесете прибор к источнику), показания плавно и предсказуемо обновятся до нового уровня в течение 30 секунд.
---

  Алгоритм расчета статистической погрешности

  Помимо самого значения мощности дозы, прибор также рассчитывает и отображает относительную статистическую погрешность измерения в процентах. Этот
  параметр показывает, насколько можно "доверять" текущим показаниям.

  Проблема: Неопределенность случайных событий

  Радиоактивный распад — это случайный (стохастический) процесс. Это означает, что невозможно предсказать, когда именно произойдет следующий распад.
  Из-за этой случайности любое измерение, основанное на подсчете числа событий, имеет встроенную неопределенность.

  Например, показание 0.24 uSv/h само по себе малоинформативно. Гораздо полезнее знать, это 0.24 ± 0.50 uSv/h (очень недостоверное измерение) или 0.24
  ± 0.01 uSv/h (очень достоверное измерение). Статистическая погрешность как раз и дает эту оценку достоверности.

  Теоретическая основа: Статистика Пуассона

  Процессы случайного распада хорошо описываются распределением Пуассона. Один из ключевых выводов этой теории гласит:

  > Если за определенный промежуток времени было зарегистрировано N случайных событий, то стандартное отклонение (которое и является мерой абсолютной
  статистической погрешности) этого измерения приблизительно равно квадратному корню из N (√N).

  Простой пример:
   * Если мы насчитали 100 импульсов, абсолютная погрешность составит √100 = 10 импульсов. Это значит, что "истинное" среднее значение, скорее всего,
     лежит в диапазоне 100 ± 10 (от 90 до 110).
   * Если мы насчитали 10000 импульсов, абсолютная погрешность составит √10000 = 100 импульсов. Диапазон: 10000 ± 100.

  Обратите внимание: чем больше событий мы регистрируем, тем больше абсолютная погрешность, но тем меньше она по отношению к самому значению (10 по
  отношению к 100 — это 10%, а 100 по отношению к 10000 — это всего 1%). Именно эту относительную погрешность в процентах и рассчитывает прибор.

  Реализация в коде

  1. Получение общего числа событий (N)

  В качестве N используется общее количество импульсов, накопленное в скользящем окне за 30 секунд. Это переменная windowPulses.

  2. Формула относительной погрешности

  Относительная погрешность вычисляется как отношение стандартного отклонения к измеренному значению:
   * Относительная погрешность = (√N) / N

  Эту дробь можно математически упростить до 1 / √N.

  Чтобы выразить это значение в процентах, мы просто умножаем результат на 100.
   * Относительная погрешность (%) = (1 / √N) * 100  или  100 / √N

  3. Код расчета

  Именно эта формула и реализована в  коде:
```
   float errorPercent = 0.0;
   // Проверяем, что импульсы вообще были, чтобы избежать деления на ноль
   if (windowPulses > 0) {
     //           100.0      /      √N
     errorPercent = 100.0 / sqrt(windowPulses);
   }
```

  Практическое значение для пользователя

  Этот процент на экране дает интуитивно понятную оценку надежности текущих показаний:

   * Высокая погрешность (например, > 20-30%): Возникает при низком радиационном фоне, когда за 30 секунд регистрируется мало импульсов. Это говорит
     пользователю, что текущее значение мощности дозы "шумное" и не очень стабильное.
   * Низкая погрешность (например, < 5%): Возникает при высоком радиационном фоне, когда за 30 секунд регистрируются сотни или тысячи импульсов. Это
     говорит о том, что измерение статистически значимо, а показания мощности дозы — надежны и стабильны.
---

  Алгоритм накопления дозы (Dose Accumulation)

  Одной из ключевых функций прибора является подсчет суммарной дозы, полученной за время измерения. Этот процесс называется накоплением дозы и работает
  параллельно с измерением текущей мощности дозы.

  Назначение и отличия от мощности дозы

  Важно понимать разницу между мощностью дозы и накопленной дозой. Для этого удобно использовать аналогию с автомобилем:

   * Мощность дозы (µSv/h): Это как спидометр в автомобиле. Он показывает, насколько "быстро" вы получаете дозу в данный момент. Значение может
     меняться каждую секунду в зависимости от радиационной обстановки.

   * Накопленная доза (µSv): Это как одометр (счетчик общего пробега). Он показывает, какую суммарную дозу вы "проехали", то есть получили с самого
     начала измерения (или с момента последнего сброса). Это значение только растет со временем.

  Накопленная доза является более важным параметром для оценки общего воздействия радиации на организм за определенный период.

  Принцип реализации в коде

  Алгоритм основан на принципе дискретного интегрирования. Так как мощность дозы — это скорость ее получения, то сама доза — это интеграл от мощности
  по времени. В цифровом виде мы аппроксимируем этот процесс путем суммирования маленьких "порций" дозы, полученных за короткие промежутки времени (в
  нашем случае — за одну секунду).

  1. Исходные данные

  Каждую секунду, после усреднения по скользящему окну, мы получаем значение мощности дозы в переменной doseRate_uSv. Единицы измерения этой переменной
  — микрозиверт в час (µSv/h).

  2. Пересчет в дозу за секунду

  Чтобы узнать, какая доза была получена за одну секунду, необходимо перевести часовую ставку в секундную. В одном часе 3600 секунд, поэтому формула
  проста:

  > Доза за секунду = (Мощность дозы в час) / 3600

  3. Суммирование (Накопление)

  Эта небольшая, полученная за секунду порция дозы, добавляется к общему счетчику накопленной дозы. Этот процесс повторяется каждую секунду.
```
   // doseRate_uSv имеет единицы [мкЗв/час]
   // Чтобы получить дозу за одну секунду, делим на 3600
   accumulatedDose_uSv += doseRate_uSv / 3600.0;
```
  Одновременно с этим увеличивается на единицу счетчик общего времени измерения:
```
   1 accumulationTime_s++;
```

  4. Непрерывность процесса

  Ключевой особенностью является то, что этот расчет происходит каждую секунду в фоновом режиме, независимо от того, какой экран выбран пользователем.
  Благодаря этому, даже если пользователь находится на основном экране, накопление дозы не прекращается, и при переключении на экран накопленной дозы
  он увидит актуальное суммарное значение.

  Сброс измерений

  При длительном нажатии на кнопку вызывается функция resetMeasurements(). Она обнуляет как счетчик накопленной дозы, так и счетчик времени, что
  позволяет начать новый сеанс измерения с нуля.
```
   void resetMeasurements() {
     // ... (сброс других переменных)
     accumulatedDose_uSv = 0.0;
     accumulationTime_s = 0;
   }
```

---
В перспективе:

* Принцип подсчета импульсов (работа с прерыванием).
* Логика накопления дозы.
