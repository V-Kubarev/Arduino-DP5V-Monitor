  Алгоритм скользящего окна (Sliding Window Algorithm)

  Для получения стабильных и достоверных показаний мощности дозы в проекте используется алгоритм усреднения данных по методу скользящего окна. Ниже
  приведено детальное описание его работы.

  Проблема: Случайная природа радиации

  Радиоактивный распад является стохастическим (случайным) процессом. Даже при неизменном радиационном фоне количество частиц, регистрируемых
  детектором за единицу времени, постоянно колеблется. Измерение количества импульсов в секунду (CPS - Counts Per Second) на основе данных только за
  последнюю секунду привело бы к следующим проблемам:

   * Нестабильность показаний: Значения на дисплее постоянно "прыгали" бы (например, 0, 2, 1, 0, 3...), что делает невозможным адекватную оценку
     текущего уровня.
   * Низкая достоверность: Односекундное измерение не является статистически значимым, особенно при низких уровнях радиации.

  Решение: Усреднение по скользящему окну

  Чтобы решить эту проблему, применяется усреднение данных за более длительный, но постоянно обновляемый промежуток времени. Алгоритм скользящего окна
  реализует именно этот подход.

  Основная идея: В любой момент времени мы оперируем средним значением, вычисленным на основе данных за последние N секунд (в данном проекте N = 30).
  Каждую новую секунду самые свежие данные добавляются в набор для усреднения, а самые старые (которые были N+1 секунду назад) — отбрасываются. Таким
  образом, окно измерений как бы "скользит" по временной шкале, всегда оставаясь актуальным.

  Принцип реализации в коде

  Для эффективной реализации алгоритма используется кольцевой (или циклический) буфер.


  1. Кольцевой буфер

  В коде создается массив, который хранит количество импульсов, зарегистрированное за каждую из последних 30 секунд.
```
    #define WINDOW_SECONDS 30
    unsigned int cpsBuffer[WINDOW_SECONDS] = {0};
```

  Этот массив можно представить как 30 ячеек памяти, каждая для своей секунды.


  2. Ежесекундное обновление

  Раз в секунду основной цикл выполняет блок кода, отвечающий за обновление данных.


  3. Запись новых данных

  Сначала вычисляется количество импульсов, произошедших за последнюю секунду, а затем это значение записывается в текущую ячейку буфера. Указатель на
  текущую ячейку хранится в переменной bufferIndex.
```
   // Вычисляем импульсы за прошедшую секунду
   unsigned int pulsesThisSecond = currentCount - lastPulseSnapshot;
   // Записываем их в текущую ячейку
   cpsBuffer[bufferIndex] = pulsesThisSecond;
```

  4. Сдвиг окна

  После записи новых данных указатель bufferIndex сдвигается на следующую ячейку. Для "зацикливания" буфера используется оператор остатка от деления
  (%).
  ```
  bufferIndex = (bufferIndex + 1) % WINDOW_SECONDS;
  ```
  Когда bufferIndex достигает значения 29, на следующей итерации (29 + 1) % 30 дает в результате 0. Указатель возвращается в начало массива, и новыеданные начинают перезаписывать самые старые значения. Именно так и реализуется "скольжение" —    старые данные автоматически "забываются".


  5. Расчет среднего значения (CPS)

  Каждую секунду, после обновления буфера, программа заново вычисляет сумму всех значений в 30 ячейках.
```
   unsigned long windowPulses = 0;
   for (unsigned int i = 0; i < WINDOW_SECONDS; i++) {
     windowPulses += cpsBuffer[i];
   }
```
  Полученное значение windowPulses — это общее количество импульсов за последние 30 секунд. Для нахождения среднего значения в секунду (CPS), эта сумма
  делится на длительность окна.
```
    float cps = windowPulses / (float)WINDOW_SECONDS;
```
  Именно это усредненное значение CPS затем используется для всех дальнейших расчетов (мощности дозы, погрешности и т.д.).

  Преимущества данного подхода

   * Стабильность: Алгоритм эффективно сглаживает случайные флуктуации, предоставляя пользователю стабильное и легко читаемое значение.
   * Актуальность: В отличие от простого накопления, метод использует только свежие данные. Если радиационная обстановка изменится (например, вы
     поднесете прибор к источнику), показания плавно и предсказуемо обновятся до нового уровня в течение 30 секунд.

---
В перспективе:

* Принцип подсчета импульсов (работа с прерыванием).
* Логика накопления дозы.
* Принцип расчета статистической погрешности.
